{"name":"Bluetti","type":"com.fibaro.genericDevice","apiVersion":"1.3","initialProperties":{"viewLayout":{"$jason":{"body":{"header":{"style":{"height":"0"},"title":"quickApp_device_4694"},"sections":{"items":[{"components":[{"name":"spm_01","style":{"weight":"1.2"},"text":"Split Phase Mode : ","type":"label","visible":true},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"name":"spm_02","style":{"weight":"1.2"},"text":"AC Output Mode :","type":"label","visible":true},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"name":"spm_03","style":{"weight":"1.2"},"text":"Auto sleep Mode :","type":"label","visible":true},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"name":"spm_04","style":{"weight":"1.2"},"text":"UPS Mode :","type":"label","visible":true},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"}]}},"head":{"title":"quickApp_device_4694"}}},"uiView":[{"components":[{"name":"spm_01","style":{"weight":"1.0"},"text":"Split Phase Mode : ","type":"label","visible":true}],"style":{"weight":"1.0"},"type":"horizontal"},{"components":[{"name":"spm_02","style":{"weight":"1.0"},"text":"AC Output Mode :","type":"label","visible":true}],"style":{"weight":"1.0"},"type":"horizontal"},{"components":[{"name":"spm_03","style":{"weight":"1.0"},"text":"Auto sleep Mode :","type":"label","visible":true}],"style":{"weight":"1.0"},"type":"horizontal"},{"components":[{"name":"spm_04","style":{"weight":"1.0"},"text":"UPS Mode :","type":"label","visible":true}],"style":{"weight":"1.0"},"type":"horizontal"}],"useUiView":true,"uiCallbacks":[],"quickAppVariables":[{"name":"SDM_ACTIVE","type":"string","value":"false"},{"name":"MQTT_IP","type":"string","value":"192.168.100.20"},{"name":"MQTT_PORT","type":"string","value":"1883"},{"name":"MQTT_TOPIC","type":"string","value":"bluetti/state/EP500P-123456781111"},{"name":"UNIT_IDS","type":"string","value":"1"},{"name":"INTERVALL","type":"string","value":"30"},{"name":"ICON_PARENT","type":"string","value":"1144"},{"name":"ICON_CHILDS","type":"string","value":"1156"},{"name":"ICON_SWITCHES","type":"string","value":"1039100"},{"name":"DEVICE_TYPE","type":"string","value":"Bluetti"},{"name":"BLUETTI_SN","type":"string","value":"2311000040912"},{"name":"W_OUT_CORR","type":"string","value":"1.0"},{"name":"W_IN_CORR","type":"string","value":"1"}],"typeTemplateInitialized":true,"userDescription":""},"initialInterfaces":[],"files":[{"name":"main","isMain":true,"isOpen":true,"content":"local ChildDevicesDetails = {\n    {name=\"AC In V\",        device_type=\"Bluetti\", register=\"ac_input_voltage\",    enabled=true, type=\"com.fibaro.meter\", rateType=\"consumption\", unit=\"V\"},\n    {name=\"AC In W\",        device_type=\"Bluetti\", register=\"ac_input_power\",    enabled=true, type=\"com.fibaro.powerMeter\", rateType=\"consumption\", unit=\"W\"},\n    {name=\"AC In Frequenz\", device_type=\"Bluetti\", register=\"ac_input_frequency\",    enabled=true, type=\"com.fibaro.meter\", rateType=\"consumption\", unit=\"Hz\"},\n    {name=\"AC Out V\",        device_type=\"Bluetti\", register=\"internal_ac_voltage\",    enabled=true, type=\"com.fibaro.meter\", rateType=\"production\", unit=\"V\"},\n    {name=\"AC Out W\",       device_type=\"Bluetti\", register=\"ac_output_power\",   enabled=true, type=\"com.fibaro.powerMeter\", rateType=\"production\", unit=\"W\"},\n    {name=\"AC Out Frequenz\", device_type=\"Bluetti\", register=\"internal_ac_frequency\",    enabled=true, type=\"com.fibaro.meter\", rateType=\"production\", unit=\"Hz\"},\n    {name=\"DC In V\",        device_type=\"Bluetti\", register=\"dc_input_voltage1\", enabled=true, type=\"com.fibaro.meter\", rateType=\"consumption\", unit=\"V\"}, \n    {name=\"DC In W\",        device_type=\"Bluetti\", register=\"dc_input_power\",    enabled=true, type=\"com.fibaro.powerMeter\", rateType=\"consumption\", unit=\"W\"},\n    {name=\"DC In W1\",       device_type=\"Bluetti\", register=\"dc_input_power1\",   enabled=true, type=\"com.fibaro.powerMeter\", rateType=\"consumption\", unit=\"W\"},\n    {name=\"DC In A1\",       device_type=\"Bluetti\", register=\"dc_input_current1\", enabled=true, type=\"com.fibaro.meter\", rateType=\"consumption\", unit=\"A\"},\n    {name=\"DC Out W\",       device_type=\"Bluetti\", register=\"dc_output_power\",   enabled=true, type=\"com.fibaro.powerMeter\", rateType=\"production\", unit=\"W\"},\n    {name=\"Einspeisung kWh\",device_type=\"Bluetti\", register=\"power_generation\",  enabled=true, type=\"com.fibaro.energyMeter\", rateType=\"production\", unit=\"kWh\"},\n    {name=\"Batterie SoC\",   device_type=\"Bluetti\", register=\"total_battery_percent\", enabled=true, type=\"com.fibaro.meter\", rateType=\"consumption\", unit=\"%\"},\n    {name=\"Battery Range Start\", device_type=\"Bluetti\", register=\"battery_range_start\", enabled=true, type=\"com.fibaro.meter\", rateType=\"consumption\", unit=\"%\", step=1, min=0, max=100},\n    {name=\"Battery Range End\", device_type=\"Bluetti\", register=\"battery_range_end\", enabled=true, type=\"com.fibaro.meter\", rateType=\"consumption\", unit=\"%\", step=1, min=0, max=100},\n    {name=\"AC Output\",      device_type=\"Bluetti\", register=\"ac_output_on\",    enabled=true, type=\"com.fibaro.binarySensor\", rateType=\"production\", unit=\"\"},\n    {name=\"DC Output\",      device_type=\"Bluetti\", register=\"dc_output_on\",    enabled=true, type=\"com.fibaro.binarySensor\", rateType=\"production\", unit=\"\"},\n    {name=\"Netzladung\",    device_type=\"Bluetti\", register=\"grid_charge_on\",  enabled=true, type=\"com.fibaro.binarySensor\", rateType=\"consumption\", unit=\"\"},\n    {name=\"Time Control\",   device_type=\"Bluetti\", register=\"time_control_on\", enabled=true, type=\"com.fibaro.binarySensor\", rateType=\"consumption\", unit=\"\"},\n    {name=\"Split Phase\", device_type=\"Bluetti\", register=\"split_phase_on\", enabled=true, type=\"com.fibaro.binarySensor\", rateType=\"consumption\", unit=\"\"},\n    {name=\"AC Output Switch\", device_type=\"Bluetti\", register=\"ac_output_switch\", enabled=true, type=\"com.fibaro.binarySwitch\", rateType=\"production\", unit=\"\"},\n    {name=\"DC Output Switch\", device_type=\"Bluetti\", register=\"dc_output_switch\", enabled=true, type=\"com.fibaro.binarySwitch\", rateType=\"production\", unit=\"\"},\n    {name=\"UPS Benutzerdefiniert\", device_type=\"Bluetti\", register=\"CUSTOMIZED\", enabled=true, type=\"com.fibaro.binarySwitch\", rateType=\"production\", unit=\"\"},\n    {name=\"UPS Standard\", device_type=\"Bluetti\", register=\"STANDARD\", enabled=true, type=\"com.fibaro.binarySwitch\", rateType=\"production\", unit=\"\"},\n    {name=\"UPS PV Prio\", device_type=\"Bluetti\", register=\"PV_PRIORITY\", enabled=true, type=\"com.fibaro.binarySwitch\", rateType=\"production\", unit=\"\"},\n    {name=\"UPS Zeitgesteuert\", device_type=\"Bluetti\", register=\"TIME_CONTROL\", enabled=true, type=\"com.fibaro.binarySwitch\", rateType=\"production\", unit=\"\"}\n}\n \n\n-- Mapping von Topics zu Geräteeigenschaften\nlocal topicToDeviceMap = {}\nfor _, device in ipairs(ChildDevicesDetails) do\n    topicToDeviceMap[device.register] = device\nend\n\n-- QuickApp-Variablen\nlocal brokerURI = \"mqtt://192.168.100.20:1883\"\nlocal baseTopic = \"bluetti/state/EP500P-123456781111\"\nlocal subscribeTopic = baseTopic .. \"/#\"\nlocal publishTopic = \"bluetti/command/EP500P-123456781111/\"\nlocal INTERVALL = 15 -- Intervall in Sekunden\nMQTT_TOPIC      = baseTopic\n\nlocal MQTT_IP            = \"0.0.0.0\"\nlocal MQTT_PORT          = 1883\nlocal ICON_PARENT        = 1144 -- Die ID des Icons\nlocal ICON_CHILDS        = 1144\nlocal SDM_ACTIVE         = \"true\" -- if false then inactive\nlocal W_IN_CORR          = 1\nlocal W_OUT_CORR         = 1\n\n-- Gemeinsame Basisklasse für gemeinsame Initialisierungslogik\nclass 'BaseMeter' (QuickAppChild)\n\nfunction BaseMeter:__init(device)\n    QuickAppChild.__init(self, device)\n    ----self:debug(self.className .. \" init\")\nend\n\nfunction BaseMeter:sendMessage(topicSuffix, message)\n    if self.parent and self.parent.sendMessage then\n        self.parent:sendMessage(topicSuffix, message)\n    else\n        self:error(\"sendMessage method is not available in parent\")\n    end\nend\n\n-- Unterklassen, die von BaseMeter erben\nclass 'PowerMeter' (BaseMeter)\nclass 'EnergyMeter' (BaseMeter)\nclass 'Meter' (BaseMeter)\nclass 'BinarySwitch' (BaseMeter)\nclass 'BinarySensor' (BaseMeter)\n\nfunction PowerMeter:__init(device)\n    BaseMeter.__init(self, device)\n    ----self:debug(\"PowerMeter init\")\nend\n\nfunction EnergyMeter:__init(device)\n    BaseMeter.__init(self, device)\n    ----self:debug(\"EnergyMeter init\")\nend\n\nfunction Meter:__init(device)\n    BaseMeter.__init(self, device)\n    ----self:debug(\"Meter init\")\nend\n\nfunction BinarySwitch:__init(device)\n    BaseMeter.__init(self, device)\n    local unitId = 1\n    if device.name == \"AC Output Switch UID \" .. tostring(unitId) then\n        if self.parent then\n            local acOutputValue = self.parent:getInitialValue(\"AC Output\", unitId)\n            self:updateProperty(\"value\", acOutputValue)\n            self.currentState = acOutputValue\n        else\n            self:updateProperty(\"value\", false)\n            self.currentState = false\n        end\n    elseif device.name == \"DC Output Switch UID \" .. tostring(unitId) then\n        if self.parent then\n            local dcOutputValue = self.parent:getInitialValue(\"DC Output\", unitId)\n            self:updateProperty(\"value\", dcOutputValue)\n            self.currentState = dcOutputValue\n        else\n            self:updateProperty(\"value\", false)\n            self.currentState = false\n        end\n     else\n        self.currentState = self:getInitialState()\n    end\nend\n\nfunction BinarySwitch:getInitialState()\n    return self:getValue()\nend\n\nfunction BinarySwitch:getValue()\n    return fibaro.getValue(self.id, \"value\")\nend\n\nfunction BinarySwitch:turnOn()\n    local function resetOtherUPSSwitches(currentDeviceID)\n        local upsDevices = {\n            \"UPS Benutzerdefiniert\",\n            \"UPS Standard\",\n            \"UPS PV Prio\",\n            \"UPS Zeitgesteuert\"\n        }\n\n        for _, deviceName in ipairs(upsDevices) do\n            local ChildID = self.parent and self.parent:getChildDeviceIDByName(deviceName)\n            if ChildID and ChildID ~= currentDeviceID then\n                ----self:debug(\"Setting UPS switch \" .. deviceName .. \" to false\")\n                fibaro.call(tonumber(ChildID), \"setProperty\", \"value\", \"false\")\n            end\n        end\n    end\n\n    local function processSwitch(deviceName, message, value)\n        local ChildID = self.parent and self.parent:getChildDeviceIDByName(deviceName)\n        if self.id == ChildID then\n            ----self:debug(\"Attempting to turn on BinarySwitch for device \" .. self.id)\n            if self.sendMessage then\n                if string.find(deviceName, \"UPS\") then\n                    resetOtherUPSSwitches(ChildID)\n                end\n                self:sendMessage(message, value)\n                self:updateProperty(\"value\", true)\n            else\n                self:error(\"sendMessage method is not available\")\n            end\n            return true\n        end\n        return false\n    end\n\n    local devices = {\n        {name = \"AC Output Switch\", message = \"ac_output_on\", value = \"ON\"},\n        {name = \"DC Output Switch\", message = \"dc_output_on\", value = \"ON\"},\n        {name = \"UPS Benutzerdefiniert\", message = \"ups_mode\", value = \"CUSTOMIZED\"},\n        {name = \"UPS Standard\", message = \"ups_mode\", value = \"STANDARD\"},\n        {name = \"UPS PV Prio\", message = \"ups_mode\", value = \"PV_PRIORITY\"},\n        {name = \"UPS Zeitgesteuert\", message = \"ups_mode\", value = \"TIME_CONTROL\"},\n    }\n\n    for _, device in ipairs(devices) do\n        if processSwitch(device.name, device.message, device.value) then\n            return\n        end\n    end\n\n    self:updateProperty(\"value\", true)\nend\n\nfunction BinarySwitch:turnOff()\n    local ChildID = self.parent and self.parent:getChildDeviceIDByName(\"AC Output Switch\")\n    if self.id == ChildID then\n        --self:debug(\"Attempting to turn off BinarySwitch for device \" .. self.id)\n        if self.sendMessage then\n            self:sendMessage(\"ac_output_on\", \"OFF\")\n            self:updateProperty(\"value\", false)\n        else\n            self:error(\"sendMessage method is not available\")\n        end\n    else\n        ChildID = self.parent and self.parent:getChildDeviceIDByName(\"DC Output Switch\")\n        if self.id == ChildID then\n            --self:debug(\"Attempting to turn off BinarySwitch for device \" .. self.id)\n            if self.sendMessage then\n                self:sendMessage(\"dc_output_on\", \"OFF\")\n                self:updateProperty(\"value\", false)\n            else\n                self:error(\"sendMessage method is not available\")\n            end\n        else\n            self:updateProperty(\"value\", false)\n        end\n    end\nend\n\nclass 'BinarySensor' (BaseMeter)\n\nfunction BinarySensor:__init(device)\n    BaseMeter.__init(self, device)\n    self.currentState = self:getInitialState()\n    --self:debug(\"BinarySensor init, initial state: \" .. tostring(self.currentState))\nend\n\nfunction BinarySensor:getInitialState()\n    return self:getValue()\nend\n\nfunction BinarySensor:getValue()\n    return fibaro.getValue(self.id, \"value\") == \"true\"\nend\n\nfunction BinarySensor:updateState(newState)\n    if newState ~= self.currentState then\n        self.currentState = newState\n        self:updateProperty(\"value\", newState)\n        --self:debug(\"BinarySensor state updated to: \" .. tostring(newState))\n    end\nend\n\n-- Initialisiere den MQTT-Client\nfunction QuickApp:onInit()\n    --self:debug(\"QuickApp:onInit\")\n    self:initChildDevices({\n        [\"com.fibaro.powerMeter\"] = PowerMeter,\n        [\"com.fibaro.energyMeter\"] = EnergyMeter,\n        [\"com.fibaro.meter\"] = Meter,\n        [\"com.fibaro.binarySwitch\"] = BinarySwitch,\n        [\"com.fibaro.binarySensor\"] = BinarySensor -- Füge diese Zeile hinzu, um sicherzustellen, dass BinarySensor verwendet wird\n    })\n    self:readDeviceVariables()\n    if tostring(SDM_ACTIVE) == \"true\" then\n        self:updateProperty(\"deviceIcon\", ICON_PARENT)\n        local unitId = 1\n        self:checkAndCreateChildDevices(unitId)\n        -- Verbindung zum MQTT-Broker herstellen\n        self:connectToBroker()\n        self:startPolling()\n        --self:debug(\"Quick App gestartet\")\n    else\n        --self:debug(\"SDM_ACTIVE == false, Abfrage ist inaktiv\")\n    end\nend\n\nfunction QuickApp:readDeviceVariables()\n    local function ensureVariableExists(name, defaultValue)\n        local value = self:getVariable(name)\n        if value == nil or value == '' then\n            self:setVariable(name, tostring(defaultValue))\n            value = tostring(defaultValue)\n        end\n        return value\n    end\n\n    MQTT_IP = ensureVariableExists(\"MQTT_IP\", \"192.168.100.20\")\n    MQTT_PORT = ensureVariableExists(\"MQTT_PORT\", \"1883\")\n    MQTT_TOPIC = ensureVariableExists(\"MQTT_TOPIC\", \"bluetti/state/EP500P-123456781111\")\n    BLUETTI_SN = ensureVariableExists(\"BLUETTI_SN\", \"123456781111\")\n    UNIT_IDS = ensureVariableExists(\"UNIT_IDS\", \"1\")\n    INTERVALL = ensureVariableExists(\"INTERVALL\", \"15\")\n    ICON_PARENT = ensureVariableExists(\"ICON_PARENT\", \"1144\")\n    ICON_CHILDS = ensureVariableExists(\"ICON_CHILDS\", \"1148\")\n    ICON_SWITCHES = ensureVariableExists(\"ICON_SWITCHES\", \"1039100\")\n    DEVICE_TYPE = ensureVariableExists(\"DEVICE_TYPE\", \"Bluetti\")\n    SDM_ACTIVE = ensureVariableExists(\"SDM_ACTIVE\", \"true\") == \"true\"\n    W_IN_CORR = ensureVariableExists(\"W_IN_CORR\", \"1\")\n    W_OUT_CORR = ensureVariableExists(\"W_OUT_CORR\", \"1\")\n\n    MQTT_PORT = tonumber(MQTT_PORT)\n    UNIT_IDS = { tonumber(UNIT_IDS) }\n    INTERVALL = tonumber(INTERVALL)\n    ICON_PARENT = tonumber(ICON_PARENT)\n    W_IN_CORR = tonumber(W_IN_CORR)\n    W_OUT_CORR = tonumber(W_OUT_CORR)\n\n    --self:debug(\"MQTT_IP: \" .. MQTT_IP)\n    --self:debug(\"MQTT_PORT: \" .. tostring(MQTT_PORT))\n    --self:debug(\"MQTT_TOPIC: \" .. tostring(MQTT_TOPIC))\n    --self:debug(\"UNIT_IDS: \" .. table.concat(UNIT_IDS, \",\"))\n    --self:debug(\"ICON_PARENT: \" .. tostring(ICON_PARENT))\n    --self:debug(\"ICON_CHILDS: \" .. tostring(ICON_CHILDS))\n    --self:debug(\"ICON_SWITCHES: \" .. tostring(ICON_SWITCHES))\n    --self:debug(\"DEVICE_TYPE: \" .. tostring(DEVICE_TYPE))\n    --self:debug(\"INTERVALL: \" .. tostring(INTERVALL))\n    --self:debug(\"W_IN_CORR: \" .. tostring(W_IN_CORR))\n    --self:debug(\"W_OUT_CORR: \" .. tostring(W_OUT_CORR))\n    --self:debug(\"SDM_ACTIVE: \" .. tostring(SDM_ACTIVE))\nend\n\nfunction QuickApp:checkAndCreateChildDevices(unitId)\n    local existingChildDevices = self.childDevices\n    local existingDeviceNames = {}\n\n    -- Speichern der Namen der vorhandenen Geräte\n    for _, device in pairs(existingChildDevices) do\n        existingDeviceNames[device.name] = true\n    end\n\n    for _, expected in ipairs(ChildDevicesDetails) do\n        if expected.device_type == DEVICE_TYPE then\n            local uniqueName = expected.name .. \" UID \" .. unitId\n            if not existingDeviceNames[uniqueName] then\n                if tostring(expected.enabled) == \"true\" then\n                    local newDevice = {}\n                    for k, v in pairs(expected) do\n                        newDevice[k] = v\n                    end\n                    newDevice.name = uniqueName\n                    local childDevice = self:createChildDevice(newDevice, _G[expected.type])\n                    if childDevice then\n                        self:updateProperty(\"deviceIcon\", ICON_PARENT)\n                        fibaro.call(childDevice.id, \"setProperty\", \"deviceIcon\", ICON_CHILDS)\n                        fibaro.sleep(150)\n                        fibaro.call(childDevice.id, \"setProperty\", \"rateType\", \"production\")\n                        fibaro.call(childDevice.id, \"setProperty\", \"rateType\", expected.rateType)\n                        fibaro.sleep(150)\n                        fibaro.call(childDevice.id, \"setProperty\", \"manufacturer\", \"Bluetti\")\n                        fibaro.call(childDevice.id, \"setProperty\", \"model\", DEVICE_TYPE)\n                        fibaro.sleep(150)\n                        fibaro.call(childDevice.id, \"setProperty\", \"userDescription\", DEVICE_TYPE .. \"\\nChild-Device: \" .. uniqueName)\n                        fibaro.call(childDevice.id, \"setProperty\", \"unit\", expected.unit)\n                        fibaro.sleep(300)\n                    else\n                        --self:debug(\"Fehler beim Erstellen des Child-Devices: \" .. uniqueName)\n                    end\n                end\n            else\n                if tostring(expected.enabled) == \"false\" then\n                    local ChildDeviceID = self:getChildDeviceIDByName(expected.name, unitId)\n                    local success = self:removeChildDevice(ChildDeviceID)\n                    if success then\n                        --self:debug(\"Child-Device \" .. ChildDeviceID .. \" erfolgreich gelöscht.\")\n                    else\n                        --self:debug(\"Fehler beim Löschen des Child-Devices \" .. ChildDeviceID .. \".\")\n                    end\n                end\n            end\n        end\n    end\nend\n\nfunction QuickApp:connectToBroker()\n    self.client = mqtt.Client.connect(brokerURI)\n    self.client:addEventListener('connected', function(event) self:onConnected(event) end)\nend\n\n-- Erfolgreiche Verbindung behandeln\nfunction QuickApp:onConnected(event)\n    --self:debug(\"Mit dem Broker verbunden\")\n    self:subscribeToTopic()\nend\n\n-- Zum angegebenen Thema abonnieren\nfunction QuickApp:subscribeToTopic()\n    self.client:subscribe(subscribeTopic, { qos = mqtt.QoS.AT_LEAST_ONCE })\n    self.client:addEventListener('message', function(event) self:onMessage(event) end)\n    --self:debug(\"Zum Thema abonniert: \" .. subscribeTopic)\nend\n\n-- Eingehende Nachrichten behandeln\nfunction QuickApp:onMessage(event)\n    --self:debug(\"Nachricht zum Thema \" .. event.topic .. \": \" .. event.payload)\n    self:updateGlobalValues(event.topic, event.payload)\nend\n\n-- Funktion zum Aktualisieren der UPS-Schalter basierend auf dem `ups_mode`\nfunction QuickApp:updateUPSMode(currentMode)\n    local upsModes = {\n        CUSTOMIZED = \"UPS Benutzerdefiniert\",\n        STANDARD = \"UPS Standard\",\n        PV_PRIORITY = \"UPS PV Prio\",\n        TIME_CONTROL = \"UPS Zeitgesteuert\"\n    }\n\n    for mode, deviceName in pairs(upsModes) do\n        local ChildID = self:getChildDeviceIDByName(deviceName)\n        if ChildID then\n            if mode == currentMode then\n                fibaro.call(tonumber(ChildID), \"setProperty\", \"value\", \"true\")\n                --self:debug(\"Setting \" .. deviceName .. \" to true\")\n            else\n                fibaro.call(tonumber(ChildID), \"setProperty\", \"value\", \"false\")\n                --self:debug(\"Setting \" .. deviceName .. \" to false\")\n            end\n        end\n    end\nend\n\n-- Nachricht an den Broker senden\nfunction QuickApp:sendMessage(topicSuffix, message)\n    local topic = publishTopic .. topicSuffix\n    self.client:publish(topic, message, { qos = mqtt.QoS.AT_LEAST_ONCE })\n    --self:debug(\"Nachricht gesendet zum Thema \" .. topic .. \": \" .. message)\nend\n\n-- Vom Broker trennen (optional)\nfunction QuickApp:disconnectFromBroker()\n    self.client:disconnect()\n    --self:debug(\"Vom Broker getrennt\")\nend\n\n-- Hilfsfunktion zum Setzen von Eigenschaften\nfunction QuickApp:setChildDeviceValue(childName, value, multiplier)\n    local ChildID = self:getChildDeviceIDByName(childName)\n    if ChildID then\n        local newValue = tonumber(value)\n        if multiplier then\n            newValue = newValue * multiplier\n        end\n        fibaro.call(tonumber(ChildID), \"setProperty\", \"value\", newValue)\n    end\nend\n\n-- Funktion zum Aktualisieren globaler Werte\nfunction QuickApp:updateGlobalValues(topic, value)\n    if value == nil then\n        self:error(\"Value for topic \" .. topic .. \" is nil\")\n        return\n    end\n\n    topic = trim(topic)\n\n    if topic == (MQTT_TOPIC .. \"/ups_mode\") then\n        self:updateUPSMode(value)\n    else\n        -- Hier werden die anderen Topics wie bisher behandelt\n        local ChildID\n        local unitId = 1\n\n        if topic == (MQTT_TOPIC .. \"/dc_input_power\") then\n            ChildID = self:getChildDeviceIDByName(\"DC In W\")\n            if ChildID then\n                fibaro.call(tonumber(ChildID), \"setProperty\", \"value\", tonumber(value))\n            end\n        elseif topic == (MQTT_TOPIC .. \"/ac_input_voltage\") then\n            ChildID = self:getChildDeviceIDByName(\"AC In V\")\n            if ChildID then\n                fibaro.call(tonumber(ChildID), \"setProperty\", \"value\", tonumber(value))\n            end\n        elseif topic == (MQTT_TOPIC .. \"/ac_input_power\") then\n            ChildID = self:getChildDeviceIDByName(\"AC In W\")\n            if ChildID then\n                fibaro.call(tonumber(ChildID), \"setProperty\", \"value\", tonumber(value * W_IN_CORR))\n            end\n        elseif topic == (MQTT_TOPIC .. \"/internal_ac_frequency\") then\n            ChildID = self:getChildDeviceIDByName(\"AC Out Frequenz\")\n            if ChildID then\n                fibaro.call(tonumber(ChildID), \"setProperty\", \"value\", tonumber(value))\n            end\n        elseif topic == (MQTT_TOPIC .. \"/ac_input_frequency\") then\n            ChildID = self:getChildDeviceIDByName(\"AC In Frequenz\")\n            if ChildID then\n                fibaro.call(tonumber(ChildID), \"setProperty\", \"value\", tonumber(value))\n            end\n        elseif topic == (MQTT_TOPIC .. \"/total_battery_percent\") then\n            ChildID = self:getChildDeviceIDByName(\"Batterie SoC\")\n            if ChildID then\n                fibaro.call(tonumber(ChildID), \"setProperty\", \"value\", tonumber(value))\n            end\n        elseif topic == (MQTT_TOPIC .. \"/internal_ac_voltage\") then\n            ChildID = self:getChildDeviceIDByName(\"AC Out V\")\n            if ChildID then\n                fibaro.call(tonumber(ChildID), \"setProperty\", \"value\", tonumber(value))\n            end\n        elseif topic == (MQTT_TOPIC .. \"/ac_output_power\") then\n            ChildID = self:getChildDeviceIDByName(\"AC Out W\")\n            if ChildID then\n                fibaro.call(tonumber(ChildID), \"setProperty\", \"value\", tonumber(value * W_OUT_CORR))\n            end\n        elseif topic == (MQTT_TOPIC .. \"/dc_output_power\") then\n            ChildID = self:getChildDeviceIDByName(\"DC Out W\")\n            if ChildID then\n                fibaro.call(tonumber(ChildID), \"setProperty\", \"value\", tonumber(value))\n            end\n        elseif topic == (MQTT_TOPIC .. \"/power_generation\") then\n            ChildID = self:getChildDeviceIDByName(\"Einspeisung kWh\")\n            if ChildID then\n                fibaro.call(tonumber(ChildID), \"setProperty\", \"value\", tonumber(value))\n            end\n        elseif topic == (MQTT_TOPIC .. \"/auto_sleep_mode\") then\n            self:updateView(\"spm_03\", \"text\", \"Auto sleep Mode : \" .. tostring(value))\n        elseif topic == (MQTT_TOPIC .. \"/ac_output_mode\") then\n            self:updateView(\"spm_02\", \"text\", \"AC Output Mode : \" .. tostring(value))\n        elseif topic == (MQTT_TOPIC .. \"/split_phase_machine_mode\") then\n            self:updateView(\"spm_01\", \"text\", \"Split Phase Mode : \" .. tostring(value))\n        elseif topic == (MQTT_TOPIC .. \"/pack_voltage1\") then\n            ChildID = self:getChildDeviceIDByName(\"Pack Voltage\")\n            if ChildID then\n                fibaro.call(tonumber(ChildID), \"setProperty\", \"value\", tonumber(value))\n            end\n        elseif topic == (MQTT_TOPIC .. \"/pack_percent1\") then\n            ChildID = self:getChildDeviceIDByName(\"Pack Percent\")\n            if ChildID then\n                fibaro.call(tonumber(ChildID), \"setProperty\", \"value\", tonumber(value))\n            end\n        elseif topic == (MQTT_TOPIC .. \"/dc_input_voltage1\") then\n            ChildID = self:getChildDeviceIDByName(\"DC Input Voltage\")\n            if ChildID then\n                fibaro.call(tonumber(ChildID), \"setProperty\", \"value\", tonumber(value))\n            end\n        elseif topic == (MQTT_TOPIC .. \"/dc_input_power1\") then\n            ChildID = self:getChildDeviceIDByName(\"DC Input Power\")\n            if ChildID then\n                fibaro.call(tonumber(ChildID), \"setProperty\", \"value\", tonumber(value))\n            end\n        elseif topic == (MQTT_TOPIC .. \"/dc_input_current1\") then\n            ChildID = self:getChildDeviceIDByName(\"DC Input Current\")\n            if ChildID then\n                fibaro.call(tonumber(ChildID), \"setProperty\", \"value\", tonumber(value))\n            end\n        elseif topic == (MQTT_TOPIC .. \"/ac_output_on\") then\n            ChildID = self:getChildDeviceIDByName(\"AC Output\")\n            if ChildID then\n                if tostring(value) == \"ON\" then\n                    fibaro.call(tonumber(ChildID), \"setProperty\", \"value\", \"false\")\n                    ChildID = self:getChildDeviceIDByName(\"AC Output Switch\")\n                    fibaro.call(tonumber(ChildID), \"setProperty\", \"value\", \"true\") --Schalter aktiv\n                else\n                    fibaro.call(tonumber(ChildID), \"setProperty\", \"value\", \"true\")\n                    ChildID = self:getChildDeviceIDByName(\"AC Output Switch\")\n                    fibaro.call(tonumber(ChildID), \"setProperty\", \"value\", \"false\") --Schalter aktiv\n                end\n            end\n        elseif topic == (MQTT_TOPIC .. \"/dc_output_on\") then\n            ChildID = self:getChildDeviceIDByName(\"DC Output\")\n            if ChildID then\n                if tostring(value) == \"ON\" then\n                    fibaro.call(tonumber(ChildID), \"setProperty\", \"value\", \"false\")\n                    ChildID = self:getChildDeviceIDByName(\"DC Output Switch\")\n                    fibaro.call(tonumber(ChildID), \"setProperty\", \"value\", \"true\") --Schalter aktiv\n                else\n                    fibaro.call(tonumber(ChildID), \"setProperty\", \"value\", \"true\")\n                    ChildID = self:getChildDeviceIDByName(\"DC Output Switch\")\n                    fibaro.call(tonumber(ChildID), \"setProperty\", \"value\", \"false\") --Schalter inaktiv\n                end\n            end\n        elseif topic == (MQTT_TOPIC .. \"/grid_charge_on\") then\n            ChildID = self:getChildDeviceIDByName(\"Netzladung\")\n            if ChildID then\n                if tostring(value) == \"ON\" then\n                    fibaro.call(tonumber(ChildID), \"setProperty\", \"value\", \"false\")\n                else\n                    fibaro.call(tonumber(ChildID), \"setProperty\", \"value\", \"true\")\n                end\n            end\n        elseif topic == (MQTT_TOPIC .. \"/time_control_on\") then\n            ChildID = self:getChildDeviceIDByName(\"Time Control\")\n            if ChildID then\n                if tostring(value) == \"ON\" then\n                    fibaro.call(tonumber(ChildID), \"setProperty\", \"value\", \"false\")\n                else\n                    fibaro.call(tonumber(ChildID), \"setProperty\", \"value\", \"true\")\n                end\n            end\n        elseif topic == (MQTT_TOPIC .. \"/split_phase_on\") then\n            ChildID = self:getChildDeviceIDByName(\"Split Phase\")\n            if ChildID then\n                if tostring(value) == \"ON\" then\n                    fibaro.call(tonumber(ChildID), \"setProperty\", \"value\", \"false\")\n                else\n                    fibaro.call(tonumber(ChildID), \"setProperty\", \"value\", \"true\")\n                end\n            end\n        elseif topic == (MQTT_TOPIC .. \"/battery_range_start\") then\n            ChildID = self:getChildDeviceIDByName(\"Battery Range Start\")\n            if ChildID then\n                fibaro.call(tonumber(ChildID), \"setProperty\", \"value\", tonumber(value))\n            end\n        elseif topic == (MQTT_TOPIC .. \"/battery_range_end\") then\n            ChildID = self:getChildDeviceIDByName(\"Battery Range End\")\n            if ChildID then\n                fibaro.call(tonumber(ChildID), \"setProperty\", \"value\", tonumber(value))\n            end\n        elseif topic == (MQTT_TOPIC .. \"/ac_output_switch\") then\n            ChildID = self:getChildDeviceIDByName(\"AC Output Switch\")\n            if ChildID then\n                if tostring(value) == \"ON\" then\n                    fibaro.call(tonumber(ChildID), \"turnOn\")\n                else\n                    fibaro.call(tonumber(ChildID), \"turnOff\")\n                end\n            end\n        end\n    end\nend\n\n-- Startet den Polling-Mechanismus\nfunction QuickApp:startPolling()\n    self:pollBroker()\n    fibaro.setTimeout(INTERVALL * 1000, function() self:startPolling() end)\nend\n\n-- Funktion, die den Broker abfragt\nfunction QuickApp:pollBroker()\n    self:sendMessage(\"poll\", \"Requesting update from broker\")\nend\n\n-- Funktion, die die ID eines Child Devices anhand des Namens zurückgibt\nfunction QuickApp:getChildDeviceIDByName(name)\n    local unitId = 1\n    local uniqueName = name .. \" UID \" .. unitId\n    for _, device in pairs(self.childDevices) do\n        if device.name == uniqueName then\n            return device.id\n        end\n    end\n    return nil\nend\n\n-- Funktion zum Entfernen von Leerzeichen am Anfang und Ende eines Strings\nfunction trim(s)\n    return (s:gsub(\"^%s*(.-)%s*$\", \"%1\"))\nend\n"}]}